<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Event loop</title>
  <link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css">
  <script src="code.js" defer></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>Event loop</h1>

  <p>Para entender el <em>Event loop</em>, debemos empezar comprendiendo que Javascript es un lenguaje que cuenta con <strong>un único hilo de ejecución</strong> (sólo se puede ejecutar instrucciones de una en una) que puede ser bloqueado si no somos cuidadosos. <br>
  Esto es posible porque Javascript por defecto es un lenguaje de programación <strong>síncrono</strong> (aunque permite usar técnicas de programación asíncrona como promesas).</p>

  <p>Los botones de abajo bloquearán el único hilo de ejecución de Javascript mediante bucles infinitos, bucles intensivos o desbordamientos de pila por recursividad.</p>

  <form>
    <button type="button" id="btnBloqueoTotal">Iniciar bloqueo total</button>
    <br>
    <button type="button" id="btnBloqueo5seg">Iniciar bloqueo 5 segundos</button>
    <br>
    <button id="btnStackOverflow">Stack overflow</button>
  </form>

  <p>Para evitar estos bloqueos se pueden usar técnicas como dividir las tareas pesadas en partes usando <code>setTimeOut()</code>, <code>setInterval()</code> o Web workers, además de usar técnicas de programación asíncrona.</p>
  
  <h2>El stack</h2>

  <p>El <strong>stack o pila de ejecución</strong> es una característica común a la mayoría de los lenguajes de programación y es lo que permite ejecutar funciones.</p>

  <p>Cuando se ejecuta una instrucción como por ejemplo <code>console.log("Javier Mancera");</code> la instrucción se coloca en la pila de ejecución y se saca cuando se termina de ejecutar.</p>

  <p>Si la ejecución de una instrucción llama a una función que a su vez llama a otras funciones, el funcionamiento de la pila es algo más complejo.<br>
  Pensemos en el código de abajo ¿Cómo iría evolucionando la pila?</p>

  <pre>
function multiplicar(a, b){
  return a*b;
}

function cuadrado(n){
  return multiplica(n, n);
}

function calcularCuadrado(numero){
  let cuad = cuadrado(numero);
  console.log( cuad );
}

calcularCuadrado(5);
  </pre>

  <h3>La evolución de la pila</h3>

  <p id="pExplicacion">Al principio la pila estará vacía.</p>

  <div class="pila-container">
    <div id="pila"></div>
    Stack
  </div>

  <form>
    <button type="button" id="btnSiguientePaso">Siguiente paso</button>
  </form>

  <h2>Las macrotasks</h2>
  <p>Todas las instrucciones del ejemplo anterior se han ejecutado de manera síncrona.</p>
  <p>Veamos algún ejemplo de asíncronía, por ejemplo entendiendo cómo se gestionan las llamadas a <code>setTimeout()</code>.</p>
  <p>Esta función en realidad llama a una de las API del navegador que genera un temporizador (<code>Timer</code>).</p>

<pre>
function f(){
  console.log("1");
  setTimeout( ()=>{console.log("2");}, 100);
  console.log("3");
}
</pre>

  <p>¿En qué orden se mostrarán los mensajes en la consola? De manera intuitiva veremos que se mostrará <code>1, 3, 2</code>. ¿Pero qué pasará si cambiamos el tiempo de espera del temporizador a 0?</p>

<pre>
function f(){
  console.log("1");
  setTimeout( ()=>{console.log("2");}, 0);
  console.log("3");
}
</pre>

<form>
  <button type="button" id="btnTimeOutCero">Ejecutar</button>
</form>
<div class="notice" id="divTimeOutCero"></div>

  <p>¿Por qué ocurre esto? Para entenderlo debemos comprender que el <code>setTimeout</code> nos genera una <strong>macrotask</strong>, una tarea de baja prioridad que se ejecutará cuando la pila de ejecución (la stack de la que hablábamos al principio) esté vacía.</p>



  <h2>Macrotasks y microtasks</h2>

  <ul>
    <li><strong>Macrotasks:</strong> tareas de baja prioridad (operaciones de I/O, gestión de eventos, setTimeout, setInterval, Renderizado de la interfaz, generación del DOM...)</li>
    <li><strong>Microtasks:</strong> tareas de alta prioridad (promesas, MutationObserver...)</li>
  </ul>

  <p>Enlaces de interés:</p>
  <ul>
    <li><a href="https://javascript.info/event-loop">https://javascript.info/event-loop</a> (con un buen ejemplo de cómo usar <code>setTimeOut</code> para realizar tareas pesadas sin bloquear el renderizado de la interfaz)</li>
    <li><a href="https://www.youtube.com/watch?v=eiC58R16hb8">https://www.youtube.com/watch?v=eiC58R16hb8</a> (vídeo explicativo en inglés del Event Loop)</li>
  </ul>
</body>
</html>
